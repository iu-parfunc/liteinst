/*  metadata.cpp                 -*- C++ -*-
 *
 * Copyright (C) 2011, 2012 Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *   * Neither the name of Intel Corporation nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include "metadata.h"
#include <iostream>
#include <cstring>
#include <stdio.h>
#include <stdarg.h>

/*
 * Include stdint.h to define the standard integer types.
 *
 * Unfortunately Microsoft doesn't provide stdint.h until Visual Studio 2010,
 * so use our own definitions until those are available
 */

#if ! defined(_MSC_VER) || (_MSC_VER >= 1600)
#include <stdint.h>
#else
#ifndef __MS_STDINT_TYPES_DEFINED__
#define __MS_STDINT_TYPES_DEFINED__
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef __int64 int64_t;

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#endif  /* __MS_STDINT_TYPES_DEFINED__ */
#endif  /* ! defined(_MSC_VER) || (_MSC_VER >= 1600) */

// Debugging printf
#if 0
#define DBGPRINTF(_fmt, ...) dbgprintf(_fmt, __VA_ARGS__)
static void dbgprintf(const char *fmt,...)
{
    va_list args;

    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
}
#else
#define DBGPRINTF(_fmt, ...)
#endif

using namespace ZCA;

/*
 * Pointer arithmetic: add a pointer and an integer.
 */
static inline void *ptr_add (void *ptr, std::size_t offset)
{
    std::size_t ret = reinterpret_cast<std::size_t>(ptr) + offset;
    return reinterpret_cast<void*>(ret);
}

/*
 * Pointer arithmetic: subtract an integer from a pointer
 */
static inline void *ptr_subtract (void *ptr, std::size_t offset)
{
    std::size_t ret = reinterpret_cast<std::size_t>(ptr) - offset;
    return reinterpret_cast<void*>(ret);
}

/*
 * Pointer comparison: return whether p1 > p2.
 */
static inline bool ptr_gt (void *p1, void *p2)
{
    return reinterpret_cast<std::size_t>(p1) >
        reinterpret_cast<std::size_t>(p2);
}

/*
 * Pointer comparison: return whether p1 < p2.
 */
static inline bool ptr_lt (void *p1, void *p2)
{
    return reinterpret_cast<std::size_t>(p1) <
        reinterpret_cast<std::size_t>(p2);
}

/*
 * Header for a table of V1.1 annotations.
 *
 * Structures derived from Low Cost ITT Notify document and the data
 * actually generated by the compiler.
 */
struct zca_header_11_t
{
    static const std::size_t magic_sz = 16;

    uint8_t     magic[magic_sz];// Magic value - ".itt_notify_tab"
    uint16_t    version;        // Major/Minor version number
    uint16_t    entry_count;    // Count of entries that follow
    uint32_t    strings;        // Offset in bytes to string table
    uint32_t    strings_len;    // Size of string table (bytes)
    uint32_t    exprs;          // Offset in bytes to expression table
    uint32_t    exprs_len;      // Size of expression table (bytes)
};

const uint16_t ZCA_INVALID_VERSION=0xffff;
const uint16_t ZCA_1_1_VERSION=0x0101;

// Zero-padded magic value in an itt_notify annotation group
const char itt_notify_magic[zca_header_11_t::magic_sz] = ".itt_notify_tab";

/*
 * Annotation within a V1.1 table of metadata
 */
#if defined(_MSC_VER)
#pragma pack(push, 4)
#endif
struct zca_row_11_t
{
    uint64_t    anchor;     // Instruction pointer of entry
    uint32_t    probespace; // Bytes of instruction to be copied by probe
    uint32_t    annotation; // Offset of annotation string in strings table
    uint32_t    expr;       // How to compute tag parameter in intrinsic
}
#if defined(_MSC_VER)
;
#pragma pack(pop)
#else
__attribute__((packed));
#endif

/*
 * Header for a table of V1.2 annotations.
 *
 * Structures derived from Low Cost ITT Notify document and the data
 * actually generated by the compiler.
 */
struct zca_header_12_t
{
    static const std::size_t magic_sz = 16;
    
    uint8_t     magic[magic_sz];// Magic value - ".itt_notify_tab"
    uint16_t    version;        // Major/Minor version number
    uint16_t    header_size;    // Size of this structure in bytes
    uint32_t    entry_count;    // Count of entries that follow
    uint32_t    strings;        // Offset in bytes to string table
    uint32_t    strings_len;    // Size of string table (bytes)
    uint32_t    exprs;          // Offset in bytes to expression table
    uint32_t    exprs_len;      // Size of expression table (bytes)
    uint64_t    flags;          // Flags
};

const uint16_t ZCA_1_2_VERSION=0x0102;

const uint64_t zca_c_anchors_pcrel = 0x01;      // Anchor address is PC-
                                                // relative.  If not present,
                                                // anchor address is absolute

const uint64_t zca_c_have_probe_region = 0x02;  // ZCA table row has field
                                                // specifying bytes that can
                                                // be used for a probe

const uint64_t zca_c_32bit_anchor=0x04;         // The anchor address is 32bits

/*
 * Annotation within a V1.2 table of metadata.  There are two possible
 * structures, depending on whether there is a probespace field.
 */
struct zca_row_12_no_probe
{
     int64_t    anchor;     // Instruction pointer of entry
    uint32_t    annotation; // Offset of annotation string in strings table
    uint32_t    expr;       // How to compute tag parameter in intrinsic
};

// Note: 8-byte aligned on 64-bit compile but packed within binary at only
// 4-byte alignment.
#if defined(_MSC_VER)
#pragma pack(push, 4)
#endif
struct zca_row_12_w_probe
{
     int64_t    anchor;     // Instruction pointer of entry
    uint32_t    probespace; // Bytes of instruction to be copied by probe
    uint32_t    annotation; // Offset of annotation string in strings table
    uint32_t    expr;       // How to compute tag parameter in intrinsic
}
#if defined(_MSC_VER)
;
#pragma pack(pop)
#else
__attribute__((packed));
#endif

struct metadata_section_t;

const int32_t invalid_row_index = -1;

/*
 * Structure to hold information about one table of metadata within an image
 * section.
 */
struct metadata_table_t
{
    std::ptrdiff_t m_offset;        // Offset of the image in the loaded binary.
    void *m_addr;                   // Absolute address of the metadata table.
    std::size_t m_size;             // Size of the metadata table.
    metadata_table_t *m_next;       // Next metadata table in this section.
    metadata_table_t *m_prev;       // Prev metadata table in this section.
    metadata_section_t *m_parent;   // Whole metadata section containing table

    metadata_table_t (std::ptrdiff_t offset,
		      void *addr,
		      std::size_t size,
		      metadata_table_t *prev,
		      metadata_section_t *parent):
        m_offset(offset),
	m_addr(addr),
	m_size(size),
	m_next(NULL),
	m_prev(prev),
	m_parent(parent)
    {
        // Insert this node at the end of the list.
        if (prev)
            prev->m_next = this;
    }

    /*
     * If this is a metadata section, return the version number.
     */
    static uint16_t version(void *addr)
    {
        zca_header_11_t *header = reinterpret_cast<zca_header_11_t *>(addr);
        if (0 != std::memcmp(itt_notify_magic,
                             header->magic,
                             zca_header_11_t::magic_sz))
            return ZCA_INVALID_VERSION;
        return header->version;
    }

    /*
     * Set the next metadata section pointer
     */
    void set_next_section(metadata_table_t *next)
    {
        m_next = next;
    }

    /*
     * Set the next metadata section pointer
     */
    void set_prev_section(metadata_table_t *prev)
    {
        m_prev = prev;
    }

    bool is_invalid_row_index(int32_t row_index)
    {
	return (row_index < 0) || (row_index >= row_count());
    }

    /*
     * Return the index of the first metadata row in this table
     */
    int32_t first ()
    {
        return 0;
    }

    /*
     * Return the index of the last metadata row in this table
     */
    int32_t last ()
    {
	return row_count() - 1;
    }

    /*
     * Return the index of the next metadata row in this table, or
     * invalid_row_index if the specified entry was the last.
     */
    int32_t next_row(int32_t row_index)
    {
	// The row after the end is still the end
	if (invalid_row_index == row_index)
	    return invalid_row_index;

	// If we were on the last row, we're done
	if (row_count() - 1 == row_index)
	    return invalid_row_index;

	// Return the next row index
	return row_index + 1;
    }

    /*
     * Return the index of the previous metadata row in this table, or
     * invalid_row_index if there are no more rows
     */
    int32_t prev_row(int32_t row_index)
    {
	// The row before the beginning is still invalid
	if (invalid_row_index == row_index)
	    return invalid_row_index;

	// If we were on the first row, we're done
	if (0 == row_index)
	    return invalid_row_index;

	// Return the previous row index
	return row_index - 1;
    }

    virtual uint64_t flags() = 0;
    virtual uint16_t header_size() = 0;
    virtual uint32_t row_count() = 0;
    virtual uint32_t row_size() = 0;
    virtual const uint8_t* strings() = 0;
    virtual uint32_t strings_len() = 0;
    virtual const uint8_t* exprs() = 0;
    virtual uint32_t exprs_len() = 0;
    virtual bool rows_have_probespace() = 0;

    virtual void *row_address(int32_t row_index) = 0;
    virtual void *row_anchor(int32_t row_index) = 0;
    virtual uint32_t row_probespace(int32_t row_index) = 0;
    virtual const char *row_name(int32_t row_index) = 0;
    virtual const unsigned char *row_expr(int32_t row_index) = 0;

    uint32_t size()
    {
        uint32_t result = header_size();
        result += row_count() * row_size();

        return result;
    }
};

/*
 * Class to encapsulate information about one V1.1 metadata table within an
 * image section.
 */
class metadata_table_11_t: public metadata_table_t
{
private:
    zca_row_11_t *m_rows;

public:
    metadata_table_11_t (std::ptrdiff_t offset,
			 void *addr,
			 std::size_t size,
			 metadata_table_t *prev,
			 metadata_section_t *parent):
        metadata_table_t(offset, addr, size, prev, parent)
    {
	m_rows = (zca_row_11_t *)ptr_add(m_addr, header_size());
    }

    /*
     * Return flags for this table - there are none for V1.1 tables
     */
    virtual uint64_t flags()
    {
        return 0LL;
    }

    /*
     * Returns true if rows have probespace information.  This is always
     * true for V1.1 metadata tables.
     */
    virtual bool rows_have_probespace()
    {
        return true;
    }

    /*
     * Return the size of the header, in bytes
     */
    virtual uint16_t header_size()
    {
        return sizeof(zca_header_11_t);
    }

    /*
     * Return the number of rows in the table
     */
    virtual uint32_t row_count()
    {
        zca_header_11_t *header = reinterpret_cast<zca_header_11_t *>(m_addr);
        return header->entry_count;
    }

    /*
     * Returns the size of a row, in bytes
     */
    virtual uint32_t row_size()
    {
        return sizeof(zca_row_11_t);
    }

    /*
     * Returns the base address of the list of NUL-terminated strings for the
     * table. Individual rows will have an offset into this list.
     */
    virtual const uint8_t *strings()
    {
        zca_header_11_t *header = reinterpret_cast<zca_header_11_t *>(m_addr);
        return reinterpret_cast<const uint8_t *>(m_addr) + header->strings;
    }

    /*
     * Returns the size of the list of strings, in bytes
     */
    virtual uint32_t strings_len()
    {
        zca_header_11_t *header = reinterpret_cast<zca_header_11_t *>(m_addr);
        return header->strings_len;
    }

    /*
     * Returns the base address of the list of DWARF expressions for the table.
     * Individual rows will have an offset into this list of DWARF expressions
     */
    virtual const uint8_t *exprs()
    {
        zca_header_11_t *header = reinterpret_cast<zca_header_11_t *>(m_addr);
        return reinterpret_cast<const uint8_t *>(m_addr) + header->exprs;
    }

    /*
     * Size of the list of DWARF expressions, in bytes
     */
    virtual uint32_t exprs_len()
    {
        zca_header_11_t *header = reinterpret_cast<zca_header_11_t *>(m_addr);
        return header->exprs_len;
    }

    /*
     * Returns the address of the row in memory
     */
    void *row_address(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
	 	    "metadata_table_11_t::row_anchor\n", row_index);
	    return NULL;
	}

        return (void *)&m_rows[row_index];
    }

    /*
     * Returns the anchor address for the specified row
     */
    void *row_anchor(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
	 	    "metadata_table_11_t::row_anchor\n", row_index);
	    return NULL;
	}

        uint64_t address;

        // 1.1 anchor is the absolute address of the instruction.  The
        // address is fixed up by the loader

        // Copy the address into a local variable to make sure it's properly
	// aligned
        memcpy (&address, &m_rows[row_index].anchor, sizeof(address));

        // Add the offset to allow for OS' that don't fixup the address
        return reinterpret_cast<void *>(address + m_offset);
    }

    /*
     * Returns the number of bytes reserved for inserting a probe.  These
     * bytes contain one or more complete instructions and will still need
     * to be executed
     */
    virtual uint32_t row_probespace(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
		    "metadata_table_11_t::row_probespace\n", row_index);
	    return 0;
	}

        uint32_t probespace;

        // Copy the address into a local variable to make sure it's properly
	// aligned
        memcpy (&probespace, &m_rows[row_index].probespace, sizeof(probespace));

        return probespace;
    }

    /*
     * Returns the annotation name for the row
     */
    virtual const char *row_name(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
		    "metadata_table_11_t::row_name\n", row_index);
	    return NULL;
	}

        uint32_t name_offset;

        // Copy the address into a local variable to make sure it's properly
	// aligned
        memcpy (&name_offset, &m_rows[row_index].annotation, sizeof(name_offset));

        // Add the offset to the base of the string table for this
        // section to find the annotation name for this entry
        return reinterpret_cast<const char *>(strings()) + name_offset;
    }

    /*
     * Returns the DWARF expression used to locate the data for the row
     */
    virtual const unsigned char *row_expr(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
		    "metadata_table_11_t::row_expr\n", row_index);
	    return NULL;
	}

        uint32_t expr_offset;

        // Copy the address into a local variable to make sure it's properly
	// aligned
        memcpy (&expr_offset, &m_rows[row_index].expr, sizeof(expr_offset));

        // Add the offset to the base of the expression table for this
        // section to find the expression for this entry
        return reinterpret_cast<const unsigned char *>(exprs()) + expr_offset;
    }
};

/*
 * Class to encapsulate information about one V1.2 metadata table within an
 * image section.
 */
class metadata_table_12_t: public metadata_table_t
{
private:
    void *m_rows;

public:
    metadata_table_12_t (std::ptrdiff_t offset,
                            void *addr,
                            std::size_t size,
                            metadata_table_t *prev,
                            metadata_section_t *parent):
        metadata_table_t(offset, addr, size, prev, parent)
    {
	m_rows = ptr_add(m_addr, header_size());
    }

    /*
     * Return flags for this table
     */
    virtual uint64_t flags()
    {
        zca_header_12_t *header = reinterpret_cast<zca_header_12_t *>(m_addr);
        return header->flags;
    }

    /*
     * Returns true if rows have probespace information.
     */
    virtual bool rows_have_probespace()
    {
        return zca_c_have_probe_region ==
            (zca_c_have_probe_region & flags());
    }

    /*
     * Return the size of the header, in bytes
     */
    virtual uint16_t header_size()
    {
        zca_header_12_t *header = reinterpret_cast<zca_header_12_t *>(m_addr);
        return header->header_size;
    }

    /*
     * Return the number of rows in the table
     */
    virtual uint32_t row_count()
    {
        zca_header_12_t *header = reinterpret_cast<zca_header_12_t *>(m_addr);
        return header->entry_count;
    }

    /*
     * Returns the size of a row, in bytes
     */
    virtual uint32_t row_size()
    {
        if (rows_have_probespace())
            return sizeof(zca_row_12_w_probe);
        else
            return sizeof(zca_row_12_no_probe);
    }

    /*
     * Returns the base address of the list of NUL-terminated strings for the
     * table. Individual rows will have an offset into this list.
     */
    virtual const uint8_t *strings()
    {
        zca_header_12_t *header = reinterpret_cast<zca_header_12_t *>(m_addr);
        return reinterpret_cast<const uint8_t *>(m_addr) + header->strings;
    }

    /*
     * Returns the size of the list of strings, in bytes
     */
    virtual uint32_t strings_len()
    {
        zca_header_12_t *header = reinterpret_cast<zca_header_12_t *>(m_addr);
        return header->strings_len;
    }

    /*
     * Returns the base address of the list of DWARF expressions for the table.
     * Individual rows will have an offset into this list of DWARF expressions
     */
    virtual const uint8_t *exprs()
    {
        zca_header_12_t *header = reinterpret_cast<zca_header_12_t *>(m_addr);
        return reinterpret_cast<const uint8_t *>(m_addr) + header->exprs;
    }

    /*
     * Size of the list of DWARF expressions, in bytes
     */
    virtual uint32_t exprs_len()
    {
        zca_header_12_t *header = reinterpret_cast<zca_header_12_t *>(m_addr);
        return header->exprs_len;
    }

    /*
     * Returns the address of the row in memory
     */
    void *row_address(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
	 	    "metadata_table_11_t::row_anchor\n", row_index);
	    return NULL;
	}

        if (rows_have_probespace())
        {
            zca_row_12_w_probe *rows = (zca_row_12_w_probe *)m_rows;
	    return (void *)&rows[row_index];
        }
        else
        {
            zca_row_12_no_probe *rows = (zca_row_12_no_probe *)m_rows;
	    return (void *)&rows[row_index];
        }
    }

    /*
     * Returns the anchor address for the specified row
     */
    void *row_anchor(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
		    "metadata_table_12_t::row_anchor\n", row_index);
	    return NULL;
	}

        int64_t address;
        uint64_t header_flags = flags();

        if (rows_have_probespace())
        {
            zca_row_12_w_probe *rows = (zca_row_12_w_probe *)m_rows;
            memcpy (&address, &rows[row_index].anchor, sizeof(address));
        }
        else
        {
            zca_row_12_no_probe *rows = (zca_row_12_no_probe *)m_rows;
            memcpy (&address, &rows[row_index].anchor, sizeof(address));
        }

        // If zca_c_32bit_anchor is set, then the high 32bits of the
        // anchor value are 0.  We need to sign-extend them
        if (header_flags & zca_c_32bit_anchor)
        {
            if (0x80000000 & address)
                address |= 0xffffffff00000000LL;
        }

        // If needed, add the base offset
        if (header_flags & zca_c_anchors_pcrel)
            address += (int64_t)m_addr;

        return reinterpret_cast<void *>(address);
    }

    /*
     * Returns the number of bytes reserved for inserting a probe.  These
     * bytes contain one or more complete instructions and will still need
     * to be executed
     */
    virtual uint32_t row_probespace(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
		    "metadata_table_12_t::row_probespace\n", row_index);
	    return 0;
	}

        uint32_t probespace;

        if (rows_have_probespace())
        {
            zca_row_12_w_probe *rows = (zca_row_12_w_probe *)m_rows;
            memcpy (&probespace,
		    &rows[row_index].probespace,
		    sizeof(probespace));
        }
        else
        {
            probespace = 0;
        }

        return probespace;
    }

    /*
     * Returns the annotation name for the row
     */
    virtual const char *row_name(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
		    "metadata_table_12_t::row_name\n", row_index);
	    return NULL;
	}

        uint32_t name_offset;

        if (rows_have_probespace())
        {
            zca_row_12_w_probe *rows = (zca_row_12_w_probe *)m_rows;
	    memcpy (&name_offset,
		    &rows[row_index].annotation,
		    sizeof(name_offset));
        }
        else
        {
            zca_row_12_no_probe *rows = (zca_row_12_no_probe *)m_rows;
	    memcpy (&name_offset,
		    &rows[row_index].annotation,
		    sizeof(name_offset));
        }

        // Add the offset to the base of the string table for this
        // section to find the annotation name for this entry
        return reinterpret_cast<const char *>(strings()) + name_offset;
    }

    /*
     * Returns the DWARF expression used to locate the data for the row
     */
    virtual const unsigned char *row_expr(int32_t row_index)
    {
	// Validate the row index
	if (is_invalid_row_index(row_index))
	{
	    fprintf(stderr, "Invalid row index %d passed to "
		    "metadata_table_12_t::row_expr\n", row_index);
	    return NULL;
	}

        uint32_t expr_offset;

        if (rows_have_probespace())
        {
            zca_row_12_w_probe *rows = (zca_row_12_w_probe *)m_rows;
	    memcpy (&expr_offset, &rows[row_index].expr, sizeof(expr_offset));
        }
        else
        {
            zca_row_12_no_probe *rows = (zca_row_12_no_probe *)m_rows;
	    memcpy (&expr_offset, &rows[row_index].expr, sizeof(expr_offset));
        }

        // Add the offset to the base of the expression table for this
        // section to find the expression for this entry
        return reinterpret_cast<const unsigned char *>(exprs()) + expr_offset;
    }
};

/*
 * Non-opaque ANN object.
 */
struct annotation_t
{
    // Table in which this annotation resides.  This is needed to get the
    // boundaries and avoid iterating past one end or the other, and it
    // allows seamless movement across multiple metadata sections within a
    // single binary.
    metadata_table_t *m_metadata_table;

    // Index of a row
    int32_t m_row_index;

    annotation_t(metadata_table_t *table, int32_t row_index):
        m_metadata_table(table),
        m_row_index(row_index)
    {
    }

    void *row_address()
    {
	return m_metadata_table->row_address(m_row_index);
    }

    void *address()
    {
        return m_metadata_table->row_anchor(m_row_index);
    }

    uint32_t probespace()
    {
        return m_metadata_table->row_probespace(m_row_index);
    }

    const char *name()
    {
        return m_metadata_table->row_name(m_row_index);
    }

    const unsigned char *expr()
    {
        return m_metadata_table->row_expr(m_row_index);
    }

    bool advance_row()
    {
        m_row_index = m_metadata_table->next_row(m_row_index);
        return invalid_row_index != m_row_index;
    }

    bool backup_row()
    {
        m_row_index = m_metadata_table->prev_row(m_row_index);
        return invalid_row_index != m_row_index;
    }
};

/*
 * Structure holds metadata about a metadata section in an object file.  If
 * a file has more than one metadata table, the struct uses a doubly linked
 * list to keep them associated.
 */
struct metadata_section_t
{
    metadata_table_t *m_head, *m_tail;
    ADDRINT m_low_addr, m_high_addr;     // Low and high addresses of the image
    bool m_valid;

    metadata_section_t (ADDRINT low_addr, ADDRINT high_addr)
        : m_head(NULL), m_tail(NULL), m_valid (true),
          m_low_addr(low_addr), m_high_addr(high_addr)
    { }

    bool invalidate ()
    {
        if (false == m_valid)
        {
            std::cerr<<"Can not invalidate an invalid metadata handle"<<std::endl;
            return false;
        }
        m_valid = false;
        return true;
    }

    void push_back (std::ptrdiff_t offset,
                    void *start,
                    std::size_t size)
    {
        char *addr = (char *)start;
        char *end  = addr + size;
        metadata_table_t *last_table = NULL;

        while (addr < end)
        {
            metadata_table_t *table = NULL;

            while ((addr < end) &&
                   (0 != memcmp(addr, itt_notify_magic, zca_header_11_t::magic_sz)))
                   addr++;

            if (addr == end)
                return;

            switch (metadata_table_t::version(addr))
            {
                case ZCA_1_1_VERSION:
                    table =
                        new metadata_table_11_t(offset, addr, size, m_tail, this);
//                      fprintf(stderr, "Added 1.1 metadata table starting at %p\n", addr);
                    break;

                case ZCA_1_2_VERSION:
                    table =
                        new metadata_table_12_t(offset, addr, size, m_tail, this);
//                    fprintf(stderr, "Added 1.2 metadata table starting at %p\n", addr);
                    break;
            }

            if (NULL == table)
                break;

            if (NULL == m_head)
                m_head = table;
            m_tail = table;

            if (last_table)
            {
                last_table->set_next_section(table);
                table->set_prev_section(last_table);
            }
            last_table = table;

            addr += table->size();
        }
    }

    ANN first ()
    {
        annotation_t ret(m_head, m_head->first());
        return *(reinterpret_cast<ANN*>(&ret));
    }

    ANN last ()
    {
        annotation_t ret(m_tail, m_tail->last());
        return *(reinterpret_cast<ANN*>(&ret));
    }
};

#define MAX_METADATA_HANDLES 1000

/* Array of metadata objects indexed by METADATA handles. */
static metadata_section_t *global_metadata[MAX_METADATA_HANDLES];

/* Number of allocated metadata handles. */
static METADATA n_handles;

/* Return a new handle for storing metadata metadata. */
METADATA create_metadata_handle (ADDRINT low_addr, ADDRINT high_addr)
{
    if (n_handles > MAX_METADATA_HANDLES)
        return invalid_metadata_handle();

    global_metadata[n_handles] = new metadata_section_t(low_addr, high_addr);
    return n_handles++;
}

/* Add the specified metadata section to the metadata pointed to by handle. */
bool add_metadata (METADATA m,
                   std::ptrdiff_t img_offset,
                   void *addr,
                   std::size_t size)
{
    if (invalid_metadata_handle() == m)
        return false;

    // Make sure that this is a version we support
    zca_header_11_t *header = (zca_header_11_t *)addr;
    switch (header->version)
    {
        case ZCA_1_1_VERSION:
        case ZCA_1_2_VERSION:
            global_metadata[m]->push_back(img_offset, addr, size);
            return true;

        default:
            fprintf(stderr, "Metadata version %04x not supported.\n",
                    header->version);
            return false;
    }
}

/* Invalidate a metdata handle */
void delete_metadata (IMG img, void *arg)
{
    ADDRINT low_addr = LEVEL_PINCLIENT::IMG_LowAddress (img);
    ADDRINT high_addr = LEVEL_PINCLIENT::IMG_HighAddress (img);
    for (METADATA m=0; m<n_handles; ++m)
        if (true == global_metadata[m]->m_valid)
            if (low_addr == global_metadata[m]->m_low_addr
                && high_addr == global_metadata[m]->m_high_addr)
            {
                global_metadata[m]->invalidate();
                return;
            }
}

static bool valid_metadata_handle (METADATA m) {
    if (invalid_metadata_handle() == m ||
        m < 0 ||
        m >= n_handles ||
        NULL == global_metadata[m]) {
        return false;
    }
    //std::cerr<<"Validity bit of handle "<<m<<" is "<<global_metadata[m]->valid<<std::endl;
    return global_metadata[m]->m_valid;
}

/* Return a handle to the first annotation in the given section. */
ANN head_annotation (METADATA m)
{
    if (valid_metadata_handle(m) == false) {
        return invalid_annotation_handle();
    }
    return global_metadata[m]->first();
}

/* Return a handle to the last annotation in the given section. */
ANN tail_annotation (METADATA m)
{
    if (valid_metadata_handle(m) == false) {
        return invalid_annotation_handle();
    }

    return global_metadata[m]->last();
}

/* Verify the integrity of the metadata pointed to by the handle. */
bool verify_metadata (METADATA m)
{
    if (false == valid_metadata_handle(m)) {
        return false;
    }
    //HV: Iam not sure what this verify function is supposed to do
    // I suppose this is to check if ZCA data is valid??
    //return global_metadata[m]->verify();
    return true;
}

/* Return the "invalid" handle for METADATA. */
METADATA invalid_metadata_handle ()
{
    return (METADATA)-1;
}

/* Return a handle to a's next annotation. */
ANN next_annotation (ANN& a)
{
    annotation_t &ret = reinterpret_cast<annotation_t&>(a);

    // Attempt to just advance to the next row
    if (ret.advance_row())
        return *(reinterpret_cast<ANN*>(&ret));

    // The user has iterated past the end of this metadata table.  But it
    // is possible that there is more metadata in this image.
    ret.m_metadata_table = ret.m_metadata_table->m_next;
    if (NULL == ret.m_metadata_table)
        return ANN_Invalid();
    ret.m_row_index = ret.m_metadata_table->first();
    return *(reinterpret_cast<ANN*>(&ret));
}

/* Return a handle to a's previous annotation. */
ANN prev_annotation (ANN& a)
{
    annotation_t &ret = reinterpret_cast<annotation_t&>(a);

    // Attempt to just backup to the previous row in this table
    if (ret.backup_row())
        return *(reinterpret_cast<ANN*>(&ret));

    // The user has iterated past the beginning of this metadata table.
    // But it is possible that there is more metadata in this image.
    ret.m_metadata_table = ret.m_metadata_table->m_prev;
    if (NULL == ret.m_metadata_table)
        return invalid_annotation_handle();
    ret.m_row_index = ret.m_metadata_table->last();
    return *(reinterpret_cast<ANN*>(&ret));
}


static
int decode_LEB128(const uint8_t *p, int32_t *value, size_t *len)
{
    int32_t result = 0;
    uint32_t shift = 0;
    const uint8_t *start = p;
    uint32_t size = sizeof(result) * 8;
    uint8_t byte;

    while(1)
    {
        byte = *p++;
        result |= (byte & 0x7f) << shift;
        shift += 7;
        /* sign bit of byte is second high order bit (0x40) */
        if ((byte & 0x80) == 0)
            break;
    }

    if ((shift < size) && (byte & 0x40))
        /* sign extend */
        result |= - (1 << shift);

    *len = p - start;
    *value = (int32_t)result;

    return 0;
}

/*
 * decode_ULEB128
 *
 * Decode an unsigned Little Endian Base 128 number.  Based on the DWARF spec
 * and the Wikipedia article at http://en.wikipedia.org/wiki/LEB128 .
 *
 * Note that this routine assumes that all values will fit in an
 * unsigned 32-bit word.
 */

static
int decode_ULEB128(const uint8_t *p, uint32_t *value, size_t *len)
{
    uint32_t result = 0;
    uint32_t shift = 0;
    const uint8_t *start = p;
    uint8_t byte;

    while(1)
    {
        byte = *p++;
        result |= (byte & 0x7f) << shift;
        if (0 == (byte & 0x80))
        {
            *len = p - start;
            *value = result;
            return 0;
        }
        shift += 7;
    }
}

// Subset of dwarf opcodes known to occur in our ZCA entries
enum dwarf_opcode
{
    DW_OP_lit0  = 0x30,     // Literal values
    DW_OP_lit31 = 0x4f,
    DW_OP_reg0  = 0x50,     // Register
    DW_OP_reg31 = 0x6f,
    DW_OP_breg0 = 0x70,     // Register + offset as a signed LEB128 value
    DW_OP_breg31 = 0x8f
};

// Pretty-print the dwarf expression
static void dump_dwarf(FILE* outfile, unsigned const char* expr, bool x86)
{
    // Names of registers 0 to 16.  The names of the 64-bit registers are
    // guesses for now.
    static const char* x86regnames[] =
    {
        "EAX",  // 0
        "ECX",  // 1
        "EDX",  // 2
        "EBX",  // 3
        "ESP",  // 4
        "EBP",  // 5
        "ESI",  // 6
        "EDI"   // 7
    };

    static const char *intel64regnames[] =
    {
        "RAX",  // 0
        "RDX",  // 1
        "RCX",  // 2
        "RBX",  // 3
        "RSI",  // 4
        "RDI",  // 5
        "RBP",  // 6
        "RSP",  // 7
        "R8",   // 8
        "R9",   // 9
        "R10",  // 10
        "R11",  // 11
        "R12",  // 12
        "R13",  // 13
        "R14",  // 14
        "R15",  // 15
    };

    std::size_t num_regnames;
    const char **regnames;

    if (x86)
    {
        regnames = x86regnames;
        num_regnames = sizeof(x86regnames)/sizeof(regnames[0]);
    }
    else
    {
        regnames = intel64regnames;
        num_regnames = sizeof(intel64regnames)/sizeof(intel64regnames[0]);
    }

    // The format is a leading "ULEB128" value specifying length,
    // followed by a number of "Dwarf location atoms".  The expressions
    // I've seen have been (in hex):
    //  - "01 30" 1 byte, literal 0, or not specified,
    //  - "01 54" 1 byte, register 4.  For x86, that would be ESP
    //
    // Full DWARF specification: http://www.dwarfstd.org/doc/DWARF4.pdf
    // DWARF expr specification: http://dwarfstd.org/doc/040408.1.html
    // The complete enum dwarf_location_atom for the Dwarf codes can be found
    // in subversion at cilk/trunk/eng/prod/intel/gcc/gcc/dwarf2.h

    // The expression starts with a length as an unsigned LEB128 value
    size_t leb128_bytes;
    uint32_t expr_len;
    decode_ULEB128(expr, &expr_len, &leb128_bytes);
    expr += leb128_bytes;

    // If the expression is one of the few common cases, pretty-print it.
    if (expr_len == 1)
    {
        if (DW_OP_lit0 <= *expr && *expr <= DW_OP_lit31)
        {
            // Literal integer in range 0 to 31
            fprintf(outfile, "Lit %u", *expr - DW_OP_lit0);
        }
        else if (DW_OP_reg0 <= *expr && *expr <= DW_OP_reg31)
        {
            // Register r0 to r31
            unsigned reg = *expr - DW_OP_reg0;
            if (reg < num_regnames)
                fprintf(outfile, "%s", regnames[reg]);
            else
                fprintf(outfile, "Reg%u", reg);
        }
        return;
    }

    // See if this is a register & offset pair
    if ((DW_OP_breg0 <= *expr) && (*expr <= DW_OP_breg31))
    {
        // The opcode specifies the register
        int offset, abs_offset;
        unsigned reg = *expr - DW_OP_breg0;
        expr++;
        expr_len--;

        // The offset is a signed LEB128 value
        decode_LEB128(expr, &offset, &leb128_bytes);

        const char *operand;
        if (offset < 0)
        {
            operand = "-";
            abs_offset = -offset;
        }
        else
        {
            operand = "+";
            abs_offset = offset;
        }

        if (reg < num_regnames)
            fprintf(outfile, "%s%s%d (0x%x)", regnames[reg], operand, abs_offset, abs_offset);
        else
            fprintf(outfile, "Reg%u%s%d (0x%x)", reg, operand, abs_offset, abs_offset);
        return;
    }

    // If not one of the known operations, dump up to 10 bytes of the
    // expression.
    fprintf(outfile, "Unknown:", expr_len);
    for (unsigned i = 0; i < expr_len && i < 10; ++i)
        fprintf(outfile, " %02x", expr[i]);
    if (expr_len > 10)
        fprintf(outfile, " 10 of %d bytes", expr_len);
}


/* Print the DWARF expression in the annotation */
void print_annotation (ANN& a)
{
    void *row =
        (reinterpret_cast<annotation_t*>(&a))->row_address();
    fprintf(stdout, "Annotation row at: %p\n", row);
    fprintf(stdout, "  Name:\t\t\t%s\n", annotation_name(a));
    fprintf(stdout, "  Address:\t\t%p\n", (void *)annotation_address(a));
    fprintf(stdout, "  Data Expression:\t");
    dump_dwarf (stdout, annotation_data_expression(a), true);
    fprintf(stdout, "\n");
}

/* Return the name of the given annotation. */
const char *annotation_name (ANN& a)
{
    if (false == verify_annotation(a))
        return NULL;

    return reinterpret_cast<annotation_t*>(&a)->name();
}

ADDRINT annotation_address (ANN& a)
{
    if (false == verify_annotation(a))
        return -1;

    return (ADDRINT)((reinterpret_cast<annotation_t*>(&a))->address());
}

/* Return a pointer to the annotation's data expression. */
const unsigned char *annotation_data_expression (ANN& a)
{
    if (false == verify_annotation(a))
        return NULL;

    return reinterpret_cast<annotation_t*>(&a)->expr();
}


extern int dwarf_expr_to_pin(const unsigned char *expression,
                             LEVEL_BASE::REG *reg,
                             INT32 *offset);

/* Return the register and offset corresponding to the data in the annotation,
   if they are valid, and return true.  If they are invalid, return false. */
bool annotation_register_and_offset (ZCA::ANN &a,
                                     LEVEL_PINCLIENT::REG *reg,
                                     LEVEL_PINCLIENT::INT32 *offset)
{
    const unsigned char *expr = annotation_data_expression(a);
    if (NULL == expr) return false;
    int result = dwarf_expr_to_pin(expr, reg, offset);
    if (0 == result) { // success!
        if ((REG_NONE == *reg) && (0 == *offset))
            return false;
        return true;
    } else {           // failure.
        return false;
    }
}

/* Return the amount of space reserved for inserting a probe on this
   annotation. */
LEVEL_PINCLIENT::USIZE annotation_get_probespace_bytes(ZCA::ANN &a)
{
    return reinterpret_cast<annotation_t*>(&a)->probespace();
}

/* Verify the integrity of the annotation pointed to by the handle. */
bool verify_annotation (ANN& a)
{
    return (invalid_annotation_handle()!=a);
}

/* Return the "invalid" handle for ANN. */
ANN invalid_annotation_handle ()
{
    return ANN(NULL, NULL);
}

