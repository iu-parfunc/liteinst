


int* garbage; // Global
unsigned long long minminInterval = 9999999;

unsigned long long run_all(int NUMFUNS, int MEMTRAFF) {
    int junk_acc = 0;
    unsigned long long tick1, tick2, time_acc = 0;
    
    if (NUMFUNS==1) {
      tick1=getticks();
      myEmptyFunc0();
      tick2=getticks();
      time_acc += (tick2 - tick1 - minminInterval);
      // Trash that cache:
      for (int k=0; k<MEMTRAFF; k++) junk_acc += garbage[k];      
    }
    // Calling a large # of different functions also trashes the cache:
    else 
      for (int j=0; j<NUMFUNS; j++) {
	// Call the probed function:
	tick1=getticks();
	(funtable[j])();
	tick2=getticks();
	time_acc += (tick2 - tick1 - minminInterval);
	// Trash that cache:
	for (int k=0; k<MEMTRAFF; k++) junk_acc += garbage[k];
      }

    if (junk_acc == 999999)      
      return time_acc;
    else       
      return time_acc;
}

int main(int argc, char** argv)
{
    unsigned long int i;
    struct timespec start, stop;
    unsigned long long cycles = 0;

    if (argc <= 3) {
      printf("Error: needs 3 command line arguments: F, N, M.  See README.md.");
      return 1;
    }

    unsigned long long t1, t2, minInterval;
    for(int i=0; i<10; i++) {
      t1 = getticks();
      minInterval = getticks() - t1;
      printf("Min rdtsc interval measured as: %ld\n", minInterval);
      if (minInterval < minminInterval)
	minminInterval = minInterval;
    }

    int NUMFUNS  = atoi(argv[1]);
    int NUMCALLS = atoi(argv[2]);
    int MEMTRAFF = atoi(argv[3]);
    
    printf("Initializing DynaProf... sampleOverhead benchmark: F=%d, N=%d, M=%d\n", NUMFUNS, NUMCALLS, MEMTRAFF);
    printf("  F = NUMFUNS  \n");
    printf("  N = NUMCALLS (per function) \n");
    printf("  M = MEMORYTRAFFIC, in words between calls\n");

    garbage = (int*)malloc(sizeof(int) * MEMTRAFF);
    start_profiler();
    init_funtable();

    printf("Initialization finished, now start proper benchmark.\n");
    // Warm up the code cache before timing:
    for(int i=0; i<100; i++)
      run_all(NUMFUNS, 0);
    run_all(NUMFUNS, MEMTRAFF);
    
    // clock_gettime( CLOCK_REALTIME, &start);
    for (int i=0; i<NUMCALLS; i++)
      cycles += run_all(NUMFUNS, MEMTRAFF);
    // clock_gettime( CLOCK_REALTIME, &stop);
    printf("Done.\n");

    double cycles_per = ((double)cycles) / ((double)NUMCALLS * (double)NUMFUNS);
    printf( "  %3.10f runtime in seconds\n", 
           (((stop.tv_sec*(double)1000000000)+stop.tv_nsec) - 
	    ((start.tv_sec*(double)1000000000)+start.tv_nsec))/(double)1000000000);
    printf( "  %d / (%d * %d) = %3.0f cycles per function sample (RDTSC)\n", 
	    cycles,NUMCALLS,NUMFUNS, cycles_per);
    printf( "SELFTIMED: %3.0f\n", ((double)cycles_per));

    printf( "NUMCALLS: %d, %3.0f\n", NUMCALLS, ((double)cycles_per));
    return 0;
}
