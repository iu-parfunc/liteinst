


int* garbage; // Global

int run_all(int NUMFUNS, int MEMTRAFF) {
    int junk_acc = 0;
    // Calling a large # of different functions also trashes the cache:
    for (int j=0; j<NUMFUNS; j++) {
      // Call the probed function:
      // myEmptyFunc0(); // FINISHME!! Need an array of function pointers.
      (funtable[j])();
      // Trash that cache:
      for (int k=0; k<MEMTRAFF; k++) junk_acc += garbage[k];
    }
    return junk_acc;
}

int main(int argc, char** argv)
{
    unsigned long int i;
    struct timespec start, stop;
    unsigned long long tick1,tick2,cycles;

    if (argc <= 3) {
      printf("Error: needs 3 command line arguments: F, N, M.  See README.md.");
      return 1;
    }

    int NUMFUNS  = atoi(argv[1]);
    int NUMCALLS = atoi(argv[2]);
    int MEMTRAFF = atoi(argv[3]);
    
    printf("Initializing DynaProf... sampleOverhead benchmark: F=%d, N=%d, M=%d\n", NUMFUNS, NUMCALLS, MEMTRAFF);
    printf("  F = NUMFUNS  \n");
    printf("  N = NUMCALLS (per function) \n");
    printf("  M = MEMORYTRAFFIC, in words between calls\n");

    garbage = (int*)malloc(sizeof(int) * MEMTRAFF);
    start_profiler();
    init_funtable();

    printf("Initialization finished, now start proper benchmark.\n");
    // Warm up the code cache before timing:
    run_all(NUMFUNS, MEMTRAFF);
    
    clock_gettime( CLOCK_REALTIME, &start);
    tick1=getticks();
    for (int i=0; i<NUMCALLS; i++)
      run_all(NUMFUNS, MEMTRAFF);
    tick2=getticks();
    clock_gettime( CLOCK_REALTIME, &stop);
    printf("Done.\n");

    cycles = (unsigned long long)((tick2-tick1));
    double cycles_per = ((double)cycles) / ((double)NUMCALLS * (double)NUMFUNS);
    printf( "  %3.10f runtime in seconds\n", 
           (((stop.tv_sec*(double)1000000000)+stop.tv_nsec) - 
	    ((start.tv_sec*(double)1000000000)+start.tv_nsec))/(double)1000000000);
    printf( "  %d / (%d * %d) = %3.0f cycles per function sample (RDTSC)\n", 
	    cycles,NUMCALLS,NUMFUNS, cycles_per);
    printf( "SELFTIMED: %3.0f\n", ((double)cycles_per));
    return 0;
}
