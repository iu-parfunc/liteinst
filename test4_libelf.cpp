#include <stdio.h>
#include <iostream>
#include <cstddef>
#include <string.h>
#include <err.h>
#include <fcntl.h>
#include <libelf.h> 
#include <stdlib.h>
#include <sysexits.h>
#include <unistd.h>
#include <cstdio>

#include <sys/mman.h>

using namespace std;

/* ZCA table stuff */
typedef unsigned char byte;

/*
 * Header for a table of V1.1 annotations.
 *
 * Structures derived from Low Cost ITT Notify document and the data
 * actually generated by the compiler.
 */
struct zca_header_11_t
{
    static const std::size_t magic_sz = 16;

    uint8_t     magic[magic_sz];// Magic value - ".itt_notify_tab"
    uint16_t    version;        // Major/Minor version number
    uint16_t    entry_count;    // Count of entries that follow
    uint32_t    strings;        // Offset in bytes to string table
    uint32_t    strings_len;    // Size of string table (bytes)
    uint32_t    exprs;          // Offset in bytes to expression table
    uint32_t    exprs_len;      // Size of expression table (bytes)
};

const uint16_t ZCA_INVALID_VERSION=0xffff;
const uint16_t ZCA_1_1_VERSION=0x0101;

// Zero-padded magic value in an itt_notify annotation group
const char itt_notify_magic[zca_header_11_t::magic_sz] = ".itt_notify_tab";

/*
 * Annotation within a V1.1 table of metadata
 */
#if defined(_MSC_VER)
#pragma pack(push, 4)
#endif
struct zca_row_11_t
{
    uint64_t    anchor;     // Instruction pointer of entry
    uint32_t    probespace; // Bytes of instruction to be copied by probe
    uint32_t    annotation; // Offset of annotation string in strings table
    uint32_t    expr;       // How to compute tag parameter in intrinsic
}
#if defined(_MSC_VER)
;
#pragma pack(pop)
#else
__attribute__((packed));
#endif

/*
 * Header for a table of V1.2 annotations.
 *
 * Structures derived from Low Cost ITT Notify document and the data
 * actually generated by the compiler.
 */
struct zca_header_12_t
{
    static const std::size_t magic_sz = 16;
    
    uint8_t     magic[magic_sz];// Magic value - ".itt_notify_tab"
    uint16_t    version;        // Major/Minor version number
    uint16_t    header_size;    // Size of this structure in bytes
    uint32_t    entry_count;    // Count of entries that follow
    uint32_t    strings;        // Offset in bytes to string table
    uint32_t    strings_len;    // Size of string table (bytes)
    uint32_t    exprs;          // Offset in bytes to expression table
    uint32_t    exprs_len;      // Size of expression table (bytes)
    uint64_t    flags;          // Flags
};

const uint16_t ZCA_1_2_VERSION=0x0102;

const uint64_t zca_c_anchors_pcrel = 0x01;      // Anchor address is PC-
                                                // relative.  If not present,
                                                // anchor address is absolute

const uint64_t zca_c_have_probe_region = 0x02;  // ZCA table row has field
                                                // specifying bytes that can
                                                // be used for a probe

const uint64_t zca_c_32bit_anchor=0x04;         // The anchor address is 32bits

//-----------------------------------------------------------------------------------
/* DWARF stuff */
#if ! defined(_MSC_VER) || (_MSC_VER >= 1600)
#include <stdint.h>
#else
#ifndef __MS_STDINT_TYPES_DEFINED__
#define __MS_STDINT_TYPES_DEFINED__
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef __int64 int64_t;

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned __int64 uint64_t;
#endif  /* __MS_STDINT_TYPES_DEFINED__ */
#endif  /* ! defined(_MSC_VER) || (_MSC_VER >= 1600) */

#define LIBZCA_ASSERT(expr)                            \
    do {                                               \
      if (! (expr)) {                                  \
        std::fprintf(stderr, "warning: %s\n", #expr);  \
      }                                                \
    } while (0)

/*
 * reg_vals: array of possible registers for storing data for Pin to pick up.
 * high_register: the highest possible index into reg_vals.
 *
 * These two variables are specific to x86 vs. x86-64, but are consistent across
 * Linux and Windows.
 */

#if defined _WIN64 || defined __x86_64__
/*
static REG reg_vals[16] =
{
    REG_RAX,
    REG_RDX,
    REG_RCX,
    REG_RBX,
    REG_RSI,
    REG_RDI,
    REG_RBP,
    REG_STACK_PTR,
    REG_R8,
    REG_R9,
    REG_R10,
    REG_R11,
    REG_R12,
    REG_R13,
    REG_R14,
    REG_R15
};
*/
static int high_register = 15;
#else
/*
static REG reg_vals[8] =
{
    REG_EAX,
    REG_ECX,
    REG_EDX,
    REG_EBX,
    REG_STACK_PTR,
    REG_EBP,
    REG_ESI,
    REG_EDI
};
*/
static int high_register = 7;
#endif

/*
 * decode_LEB128
 *
 * Decode a signed Little Endian Base 128 number.  Based on the DWARF spec and
 * the Wikipedia article at http://en.wikipedia.org/wiki/LEB128
 *
 * Note that this routine assumes that all decoded values will fit in a signed
 * 32-bit word.
 */

int REG_INVALID()
{
  return 99;
}

unsigned int REG_NONE = 100;

static
int decode_LEB128(const uint8_t *p, int32_t *value, size_t *len)
{
    int32_t result = 0;
    uint32_t shift = 0;
    const uint8_t *start = p;
    uint32_t size = sizeof(result) * 8;
    uint8_t byte;

    while(1)
    {
        byte = *p++;
        result |= (byte & 0x7f) << shift;
        shift += 7;
        /* sign bit of byte is second high order bit (0x40) */
        if ((byte & 0x80) == 0)
            break;
    }

    if ((shift < size) && (byte & 0x40))
        /* sign extend */
        result |= - (1 << shift);

    *len = p - start;
    *value = (int32_t)result;

    return 0;
}

/*
 * decode_ULEB128
 *
 * Decode an unsigned Little Endian Base 128 number.  Based on the DWARF spec
 * and the Wikipedia article at http://en.wikipedia.org/wiki/LEB128 .
 *
 * Note that this routine assumes that all values will fit in an
 * unsigned 32-bit word.
 */

static
int decode_ULEB128(const uint8_t *p, uint32_t *value, size_t *len)
{
    uint32_t result = 0;
    uint32_t shift = 0;
    const uint8_t *start = p;
    uint8_t byte;

    while(1)
    {
        byte = *p++;
        result |= (byte & 0x7f) << shift;
        if (0 == (byte & 0x80))
        {
            *len = p - start;
            *value = result;
            return 0;
        }
        shift += 7;
    }
}

/*
 * dwarf_expr_to_pin
 *
 * Convert a DWARF expression from the ZCA annotation to a PIN register and
 * offset. Supported DWARF expressions:
 *
 *  DW_OP_lit* - Simple small integers.  reg is set to REG_NONE.
 *  DW_OP_reg* - Simple registers.  offset is set to 0.
 *  DW_OP_breg* - A register and an offset
 *
 * Returns:
 * 0 - success
 * 1 - failure
 */

int dwarf_expr_to_pin(const unsigned char *expression,
                      unsigned int *reg,
                      int32_t *offset)
{
    // The format is a leading "ULEB128" value specifying length,
    // followed by a number of "Dwarf location atoms".  The expressions
    // I've seen have been (in hex):
    //  - "01 30" 1 byte, literal 0, or not specified,
    //  - "01 54" 1 byte, register 4.  For x86, that would be ESP
    //
    // Full DWARF specification: http://www.dwarfstd.org/doc/DWARF4.pdf
    // DWARF expr specification: http://dwarfstd.org/doc/040408.1.html
    // The complete enum dwarf_location_atom for the Dwarf codes can be found
    // in subversion at cilk/trunk/eng/prod/intel/gcc/gcc/dwarf2.h

    // The expression starts with a length as an unsigned LEB128 value
    size_t leb128_bytes;
    uint32_t expression_length;
    decode_ULEB128(expression, &expression_length, &leb128_bytes);
    expression += leb128_bytes;

    // Subset of dwarf opcodes known to occur in our ZCA entries
    enum dwarf_opcode
    {
        DW_OP_lit0  = 0x30,     // Literal values
        DW_OP_lit31 = 0x4f,
        DW_OP_reg0  = 0x50,     // Simple registers
        DW_OP_reg31 = 0x6f,
        DW_OP_breg0 = 0x70,     // Registers + offset as a signed LEB128 value
        DW_OP_breg31 = 0x8f,
    };

    // Extract the opcode
    unsigned char opcode = *expression;
    printf("Opcode: %u\n", opcode);
    // If this is a simple register, decode it
    if ((opcode >= DW_OP_reg0) && (opcode <= DW_OP_reg31))
    {
        // Length should have been 1 since the expression consists of a single
        // byte opcode
        LIBZCA_ASSERT(1 == expression_length);

        unsigned reg_number = opcode - DW_OP_reg0;
        if (reg_number <= high_register)
        {
            *reg = reg_number;
            *offset = 0;
            return 0;
        }
        else
        {
            *reg = REG_INVALID();
            *offset = 0;
            LIBZCA_ASSERT(! "Unexpected DWARF register code");
            return 1;
        }
    }

    // If this is a simple literal value, decode it
    if ((opcode >= DW_OP_lit0) && (opcode <= DW_OP_lit31))
    {
        // Length should have been 1 since the expression consists of a single
        // byte opcode
        LIBZCA_ASSERT(1 == expression_length);

        *reg = REG_NONE;
        *offset = opcode - DW_OP_lit0;
        return 0;
    }

    // If this is a register and offset, decode it
    if ((opcode >= DW_OP_breg0) && (opcode <= DW_OP_breg31))
    {
        // The opcode specifies the register
        unsigned reg_number = opcode - DW_OP_breg0;
        if (reg_number <= high_register)
        {
            *reg = reg_number;
        }
        else
        {
            *reg = REG_INVALID();
            *offset = 0;
            LIBZCA_ASSERT(! "Unexpected DWARF register code");
            return 1;
        }

        // Advance past the opcode
        expression++;
        expression_length--;

        // The offset is a signed LEB128 value
        decode_LEB128(expression, offset, &leb128_bytes);

        return 0;
    }

    LIBZCA_ASSERT(! "Unexpected DWARF register code");
    return 1;
}

// --------------------------------------------------------------------------------
// A global variable which stores the executable file name
const char *__progname;

// This code is taken from:
// http://stackoverflow.com/questions/12159595/how-to-get-a-pointer-to-an-specific-section-of-a-program-from-within-itself-ma

zca_row_11_t * retrieve_data() {
  int fd;       // File descriptor for the executable ELF file
  char *section_name, path[256];
  size_t shstrndx;

  Elf *e;           // ELF struct
  Elf_Scn *scn;     // Section index struct
  Elf64_Shdr *shdr;     // Section struct

  // Create the full path of the executable
  getcwd(path, 255);
  strcat(path, "/");
  strcat(path, __progname);

  if(elf_version(EV_CURRENT)==EV_NONE)
    errx(EXIT_FAILURE, "ELF library iinitialization failed: %s", elf_errmsg(-1));

  if((fd = open(path, O_RDONLY, 0))<0)
    err(EXIT_FAILURE, "open \"%s\" failed", path);

  if((e = elf_begin(fd, ELF_C_READ, NULL))==NULL)
    errx(EXIT_FAILURE, "elf_begin() failed: %s.", elf_errmsg(-1));

  // Retrieve the section index of the ELF section containing the string table of section names
  if(elf_getshdrstrndx(e, &shstrndx)!=0)
    errx(EXIT_FAILURE, "elf_getshdrstrndx() failed: %s.", elf_errmsg(-1));

  scn = NULL;

  zca_row_11_t * row;
  // Loop over all sections in the ELF object
  while((scn = elf_nextscn(e, scn))!=NULL) {
    // Given a Elf Scn pointer, retrieve the associated section header
    if((shdr = elf64_getshdr(scn))!=shdr)
      errx(EXIT_FAILURE, "getshdr() failed: %s.", elf_errmsg(-1));

    // Retrieve the name of the section name
    if((section_name = elf_strptr(e, shstrndx, shdr->sh_name))==NULL)
      errx(EXIT_FAILURE, "elf_strptr() failed: %s.", elf_errmsg(-1));

    printf("Found section! %s\n", section_name);

    // If the section is the one we want... (in my case, it is one of the main file sections)
    if(!strcmp(section_name, ".itt_notify_tab")) {

      // We can use the section adress as a pointer, since it corresponds to the actual
      // adress where the section is placed in the virtual memory
      struct data_t * section_data = (struct data_t *) shdr->sh_addr;

      printf("Yep, got itt_notify... data is at addr %p.  Now to parse it!\n", section_data);
      
      // Cast section data
      struct zca_header_11_t *table  = (struct zca_header_11_t*) section_data;
      row = (struct zca_row_11_t*) ((byte*) table + sizeof(*table));
      const char *str = (const char *) ((byte*) table + table->strings + row->annotation);
      const unsigned char *expr = (const unsigned char *) ((byte*) table + table->exprs + row->expr);      
      unsigned int reg = 200;
      int32_t offset = 200;

      // Put tag parameter regester and offset data into &reg and &offset
      dwarf_expr_to_pin(expr, &reg, &offset);
      
      // cout that shit
      cout << "  reg/offset: " << reg << ", " << offset << endl;
      cout << "  table " << table << ", row " << row << ", row byteoffset " << (byte*) row - (byte*) table << ", table_size "
      	   << sizeof(*table) << endl;
      cout << "  row "<< row << ": label \"" << str << "\", str offset " << (byte*) str - (byte*) table << ", strings "
	   << table->strings << ", annotation " << row->annotation 
           << ", probespace " << row->probespace
           << ", IP " << (void*)(row->anchor)
           << endl;

      // End the loop (if we only need this section)
      break;
    }
  }

  elf_end(e);
  close(fd);
  return row;
}


static void print_fn() { 
  printf("MADE IT -- to the print function!\n");
  return; 
}


// void write_abs_jump(unsigned char *opcodes, const void *jmpdest)
// {
//     opcodes[0] = 0xFF; 
//     opcodes[1] = 0x25;

//     // Whoa... does this stomp on 
//     *reinterpret_cast<DWORD *>(opcodes + 2) = reinterpret_cast<DWORD>(opcodes + 6);
//     *reinterpret_cast<DWORD *>(opcodes + 6) = reinterpret_cast<DWORD>(jmpdest);
// }

int main(int argc, char *argv[])
{
#if 0
  // This works as expected:
   asm("jmp *%0"::"r"(print_fn):);
#else
  // Instrumentation comes here 
  typedef unsigned char BYTE;
  FILE *file = NULL;
  FILE *out = NULL;
  BYTE *fileBuf;
  unsigned long fileSize;

  __progname = argv[0];

  printf("Calling retrieve_data ... \n");
  zca_row_11_t *row = retrieve_data();
  printf("  Done with retrieve, got row IP %p, probespace %d\n", (void*)row->anchor, row->probespace);

  printf("Now to self-modify... first set perms\n");
  unsigned char* ip = (unsigned char*)row->anchor;
  int page = 4096;   /* size of a page */
  // int code = mprotect(ip, page, PROT_READ | PROT_WRITE | PROT_EXEC);
  unsigned long ipn = (unsigned long)ip;
  // I think we need to mprotect a page-aligned address:
  int code = mprotect((void*)(ipn - (ipn%4096)), page, PROT_READ | PROT_WRITE | PROT_EXEC);
  if (code) {
      /* current code page is now writable and code from it is allowed for execution */
      fprintf(stderr,"mprotect was not successfull! code %d\n", code);
      return 1;
  }

  // This is an ABSOLUTE, indirect jump:
  ip[0] = 0xFF;
  ip[1] = 0x25;

  // uint32_t plain_addr = (uint32_t)(void*)(&print_fn);
  // printf("  32 bit converted addr %p / %d\n", plain_addr, plain_addr);
  int relative = (int)(long)(((unsigned char*)(void*)&print_fn) - ip);
  // long relative = (long)(((unsigned char*)(void*)&print_fn) - ip);
  printf("  Relative offset of dest from starting addr: %p  %d\n", relative, relative);
  // *(uint32_t*)(ip+2) = plain_addr;
  // *(uint32_t*)(ip+2) = relative;

  unsigned long addraddr = (unsigned long) & row->anchor;
  printf("  Address containing the dest addr: %d / %p\n", addraddr, addraddr);
  if (addraddr != (unsigned long)(unsigned int)addraddr) {
    printf("Address is more than 32 bits! %ld", addraddr);
    return 1;
  }

  // Here we write the ADDRESS to read the location from, not the location itself:
  *(uint32_t*)(ip+2) = (uint32_t)(unsigned long)& row->anchor;
  unsigned long test = 0;
  *(uint32_t*)(ip+2) = (uint32_t)&test;

  // One more test!
  // Here we write what is ALREADY there: 66 0f 1f 44 00 00 -- nopw   0x0(%rax,%rax,1)
  ip[0] = 0x66;
  ip[1] = 0x0f;  
  ip[2] = 0x1f;
  ip[3] = 0x44;  
  ip[4] = 0x00;  
  ip[5] = 0x00;

  for(int i=0; i<6; i++) 
    printf("   Byte %d of probe space = %d = %p\n", i, ip[i], ip[i]);

  printf("Destination function lives at %p.\n", &print_fn);
  printf("Finished mutating ourselves... enter the danger zone.\n");

  //------------------------------------------------------------
  int x = 5;
  __notify_intrinsic((void*)"entered region", (void*)&x);
  printf("[app] We are the borg.\n");
  __notify_intrinsic((void*)"exited", &x);
  printf("[app] Done.\n");  
  //------------------------------------------------------------
    
  // Need to open in r+b
  /*
  if ((file = fopen(argv[0], "rb")) == NULL)
    cout << "Could not open binary" << endl;
  else
    cout << "Binary opened successfully" << endl;

  if ((out = fopen("out.exe", "wb")) == NULL)
    cout << "Could not open output file" << endl;
  else
    cout << "Output file opened successfully" << endl;
  return 0;
  
  fclose(file);
  fclose(out);

  delete[] fileBuf;
  */    
#endif
}

