
/** 
 * 
 * @brief Typedefs modeling the structure of the ZCA ELF headers.
 * 
 * @details
 * This code was taken from Intel's released "libzca", specifically libzca-src-195:
 *
 * http://software.intel.com/en-us/articles/download-intel-cilk-plus-software-development-kit
 *
 * Therefore, the license for this code is:
 *
     Copyright (C) 2012 Intel Corporation
     All rights reserved.

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in
       the documentation and/or other materials provided with the
       distribution.
     * Neither the name of Intel Corporation nor the names of its
       contributors may be used to endorse or promote products derived
       from this software without specific prior written permission.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
     BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
     OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
     AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
     WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     POSSIBILITY OF SUCH DAMAGE.

 *                           -*- C language -*-
 */

#ifndef _ZCA_TYPES_H_
#define _ZCA_TYPES_H_
#ifdef __cplusplus
extern "C"
{
#endif

#include <inttypes.h>

// --------------------------------------------------------------------------------

// using namespace std;


/* ZCA table stuff */
typedef unsigned char byte;

/*
 * Header for a table of V1.1 annotations.
 *
 * Structures derived from Low Cost ITT Notify document and the data
 * actually generated by the compiler.
 */
struct zca_header_11_t
{
  // static const std::size_t magic_sz = 16;
    #define magic_sz 16

    uint8_t     magic[magic_sz];// Magic value - ".itt_notify_tab"
    uint16_t    version;        // Major/Minor version number
    uint16_t    entry_count;    // Count of entries that follow
    uint32_t    strings;        // Offset in bytes to string table
    uint32_t    strings_len;    // Size of string table (bytes)
    uint32_t    exprs;          // Offset in bytes to expression table
    uint32_t    exprs_len;      // Size of expression table (bytes)
};

const uint16_t ZCA_INVALID_VERSION=0xffff;
const uint16_t ZCA_1_1_VERSION=0x0101;

// Zero-padded magic value in an itt_notify annotation group
// const char itt_notify_magic[zca_header_11_t::magic_sz] = ".itt_notify_tab";
const char itt_notify_magic[magic_sz] = ".itt_notify_tab";

/*
 * Annotation within a V1.1 table of metadata
 */
#if defined(_MSC_VER)
#pragma pack(push, 4)
#endif
struct zca_row_11_t
{
    uint64_t    anchor;     // Instruction pointer of entry
    uint32_t    probespace; // Bytes of instruction to be copied by probe
    uint32_t    annotation; // Offset of annotation string in strings table
    uint32_t    expr;       // How to compute tag parameter in intrinsic
}
#if defined(_MSC_VER)
;
#pragma pack(pop)
#else
__attribute__((packed));
#endif

/*
 * Header for a table of V1.2 annotations.
 *
 * Structures derived from Low Cost ITT Notify document and the data
 * actually generated by the compiler.
 */
struct zca_header_12_t
{
  // static const std::size_t magic_sz = 16;
  // size_t      magic_sz = 16;
    
    uint8_t     magic[magic_sz];// Magic value - ".itt_notify_tab"
    uint16_t    version;        // Major/Minor version number
    uint16_t    header_size;    // Size of this structure in bytes
    uint32_t    entry_count;    // Count of entries that follow
    uint32_t    strings;        // Offset in bytes to string table
    uint32_t    strings_len;    // Size of string table (bytes)
    uint32_t    exprs;          // Offset in bytes to expression table
    uint32_t    exprs_len;      // Size of expression table (bytes)
    uint64_t    flags;          // Flags
};

const uint16_t ZCA_1_2_VERSION=0x0102;

const uint64_t zca_c_anchors_pcrel = 0x01;      // Anchor address is PC-
                                                // relative.  If not present,
                                                // anchor address is absolute

const uint64_t zca_c_have_probe_region = 0x02;  // ZCA table row has field
                                                // specifying bytes that can
                                                // be used for a probe

const uint64_t zca_c_32bit_anchor=0x04;         // The anchor address is 32bits

struct ann_data
{
  unsigned long* location;
  void (*func)();
  byte* const ip;
  const uint32_t probespace;
  const unsigned char* expr;

  // ann_data(unsigned long int* l, void (*f)(), byte* const i, const uint32_t ps,
  // 	   const unsigned char* e): location(l), func(f), ip(i), probespace(ps), expr(e) {}
  /*
  {
    location = l;
    func = f;
    ip = i;
    probespace = ps;
    expr = e;
  }
  */
};

#ifdef __cplusplus
}
#endif
#endif  // _ZCA_TYPES_H_
