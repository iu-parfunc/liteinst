
#include "cyg_functions.hpp"
#include "patch_utils.hpp"
#include "finstrumentor.hpp"

#include "distorm.h"
#include "../../../deps/capstone/include/capstone.h"

// How many instructions to allocate on stack.
#define MAX_INSTRUCTIONS 32

using namespace std;

/* Defining global data structures */

probe_map probe_info;
func_table functions;

static uint8_t mov_encodings[20] = {MOV_REG_8, MOV_REG_16, MOV_MEM_8, MOV_MEM_16,
  MOV_IMM_8_RAX, MOV_IMM_8_RCX, MOV_IMM_8_RDX, MOV_IMM_8_RBX,
  MOV_IMM_8_RSP, MOV_IMM_8_RBP, MOV_IMM_8_RSI, MOV_IMM_8_RDI,
  MOV_IMM_16_RAX, MOV_IMM_16_RCX, MOV_IMM_16_RDX, MOV_IMM_16_RBX,
  MOV_IMM_16_RSP, MOV_IMM_16_RBP, MOV_IMM_16_RSI,  MOV_IMM_16_RDI};

void init_ubiprof() {
}

inline bool check_if_mov(uint8_t progbit) {
  for (int i=0; i<20; i++) {
    if (mov_encodings[i] == progbit) {
      return true;
    } 
  }

  return false;
}

static csh handle;

inline void print_fn(short t) {
  // fprintf(stderr, "Do or die trying %d..\n", (int)t);
}

bool starts_with(const char *str, const char *pre) {
  size_t lenpre = strlen(pre), lenstr = strlen(str);
  return lenstr < lenpre ? false : strncmp(pre, str, lenpre) == 0;
}

typedef void (*FuncPtr)(short);

static void print_string_hex(char *comment, unsigned char *str, int len)
{
  unsigned char *c;

  printf("%s", comment);
  for (c = str; c < str + len; c++) {
    printf("0x%02x ", *c & 0xff);
  }

  printf("\n");
}

static void print_insn_detail(csh ud, cs_mode mode, cs_insn *ins)
{
  int i;
  cs_x86 *x86 = &(ins->detail->x86);

  print_string_hex("\tPrefix:", x86->prefix, 5);

  if (x86->segment != X86_REG_INVALID)
    printf("\tSegment override: %s\n", cs_reg_name(handle, x86->segment));

  print_string_hex("\tOpcode:", x86->opcode, 3);
  printf("\top_size: %u, addr_size: %u, disp_size: %u, imm_size: %u\n", x86->op_size, x86->addr_size, x86->disp_size, x86->imm_size);
  printf("\tmodrm: 0x%x\n", x86->modrm);
  printf("\tdisp: 0x%x\n", x86->disp);

  int count = cs_op_count(ud, ins, X86_OP_IMM);
  if (count) {
    printf("\timm_count: %u\n", count);
    for (i = 1; i < count + 1; i++) {
      int index = cs_op_index(ud, ins, X86_OP_IMM, i);
      // printf("\t\timms[%u]: 0x%"PRIx64 "\n", i, x86->operands[index].imm);
    }
  }

  if (x86->op_count)
    printf("\top_count: %u\n", x86->op_count);
  for (i = 0; i < x86->op_count; i++) {
    cs_x86_op *op = &(x86->operands[i]);

    switch((int)op->type) {
      case X86_OP_REG:
        printf("\t\toperands[%u].type: REG = %s\n", i, cs_reg_name(handle, op->reg));
        break;
      case X86_OP_IMM:
        // printf("\t\toperands[%u].type: IMM = 0x%"PRIx64 "\n", i, op->imm);
        break;
      case X86_OP_FP:
        printf("\t\toperands[%u].type: FP = %f\n", i, op->fp);
        break;
      case X86_OP_MEM:
        printf("\t\toperands[%u].type: MEM\n", i);
        if (op->mem.base != 0)
          printf("\t\t\toperands[%u].mem.base: REG = %s\n", i, cs_reg_name(handle, op->mem.base));
        if (op->mem.index != 0)

          printf("\t\t\toperands[%u].mem.index: REG = %s\n", i, cs_reg_name(handle, op->mem.index));
        if (op->mem.scale != 1)
          printf("\t\t\toperands[%u].mem.scale: %u\n", i, op->mem.scale);
        if (op->mem.disp != 0)
          // printf("\t\t\toperands[%u].mem.disp: 0x%" PRIx64 "\n", i, op->mem.disp);
          break;
      default:
        break;
    }
  }

  printf("\n");
}

int process_probe_site(uint64_t func_addr, uint8_t* addr) {

  cs_insn *insn;
  size_t count;
  size_t size = 32;

  uint64_t address = 0x1000;

  // Need global synchronization here
  // synchronized {
  if(functions.find(func_addr) == functions.end()) {
    functions.insert(func_table::value_type(func_addr, func_id_counter++));
  }

  Probe_Info* probe_data = new Probe_Info;

  list<Probe_Info*>* probe_list;
  if (probe_info.find(func_addr) == probe_info.end()) {
    probe_list = new list<Probe_Info*>;
    probe_list->push_back(probe_data);

    probe_info.insert(probe_map::value_type(func_addr, probe_list));
  } else {
    probe_list = probe_info.find(func_addr)->second;
    probe_list->push_back(probe_data);
  }
  // }

  if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK) {
    LOG_ERROR("Error decoding data. Skipping probe insrumentationi at %p..\n", addr);
  }

  cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);

  count = cs_disasm_ex(handle, (unsigned char *) addr-32, 32, address, 0, &insn);
  if (count) {
    int j;
    x86_reg rdi = X86_REG_RDI;
    x86_reg edi = X86_REG_EDI;
    x86_reg rsi = X86_REG_RSI;
    x86_reg esi = X86_REG_ESI;
    int param_setters_found_so_far = 0;
    int probe_site_size = 0;
    int indirect_reg = -16; // So that unset indirect_reg + 16 points to an invalid value
    bool rdi_set = false;
    for (j = count-1; j >= 0; j--) {
      if (!strcmp("mov", insn[j].mnemonic)) {
        cs_x86 *x86 = &(insn->detail->x86);

          if (x86->op_count) {
            int i;
            for (i = 0; i < x86->op_count; i++) {
              cs_x86_op *dest = &(x86->operands[i]);

              if ((int)dest->type == X86_OP_REG) {
                int dest_reg = dest->reg;
                // If the destination register is RDI or RSI we get to the business
                // For RDI we need to get to the location where the function address
                // immediate value is set. This may be via another register. In that case
                // we need to go searching up until we encounter the mov to that register
                if (dest_reg == 19 || dest_reg == rdi && i == 0
                    && i < x86->op_count-1 && !rdi_set) {
                  cs_x86_op *src = &(x86->operands[i+1]); 
                  if (src->type == X86_OP_REG) {
                    indirect_reg = src->reg;
                  } else if (src->type == X86_OP_IMM) {
                    param_setters_found_so_far++;
                    break;
                  }
                  rdi_set = true;
                } else if (dest_reg == esi || dest_reg == rsi) {
                    param_setters_found_so_far++;
                } else if (dest_reg == indirect_reg || dest_reg == indirect_reg + 16) {
                  cs_x86_op *src = &(x86->operands[i+1]); 
                  if (src->type == X86_OP_REG) {
                    indirect_reg = src->reg;
                  } else if (src->type == X86_OP_IMM) {
                    param_setters_found_so_far++;
                    break;
                  }
                }
              }
            }
          }
      }

      probe_site_size += insn[j].size;

      if (param_setters_found_so_far == 2) {
        probe_data->probe_start_addr = addr - probe_site_size;
        probe_data->size = probe_site_size;
        if (probe_site_size < 15) {
          probe_data->patch_strategy = ARGUMENT_PATCH_STRATEGY;
        } else {
          probe_data->patch_strategy = CALL_REDIRECT_STRATEGY;
        }

        fprintf(stderr, "Probe start_addr : %p probe_size : %d probe_end_addr : %p..\n", 
            probe_data->probe_start_addr, probe_data->size, addr);
        break;
      }

      // printf("%s\t%s\n", insn[j].mnemonic, insn[j].op_str);
      // print_insn_detail(handle, CS_MODE_64, &insn[j]);
    }

    // free memory allocated by cs_disasm_ex()
    cs_free(insn, count);

    cs_close(&handle);

  }

}

void __cyg_profile_func_enter(void* func, void* caller) {

  uint64_t* addr = (uint64_t*)__builtin_extract_return_addr(__builtin_return_address(0));
  fprintf(stderr, "Function Address is : %p\n", (unsigned char*) func);
  fprintf(stderr, "Call site Address is : %p\n", (unsigned char*) addr);

  size_t distance = (unsigned long)addr - (unsigned long)func;
  fprintf(stderr, "Distance is : %lu\n", distance);

  process_probe_site((uint64_t) func, (uint8_t*) addr);

  /*
  cs_insn *insn;
  size_t count;
  size_t size = 32;

  uint64_t address = 0x1000;

  if (cs_open(CS_ARCH_X86, CS_MODE_64, &handle) != CS_ERR_OK) {
    LOG_ERROR("Error decoding data. Skipping probe insrumentationi at %p..\n", addr);
  }

  cs_option(handle, CS_OPT_DETAIL, CS_OPT_ON);

  count = cs_disasm_ex(handle, (unsigned char *) addr-32, 32, address, 0, &insn);
  if (count) {
    size_t j;
    for (j = count-1; j >= 0; j--) {
      if (strcmp("mov", insn[j].mnemonic)) {


      }
      printf("%s\t%s\n", insn[j].mnemonic, insn[j].op_str);
      print_insn_detail(handle, CS_MODE_64, &insn[j]);
    }

    // free memory allocated by cs_disasm_ex()
    cs_free(insn, count);

    cs_close(&handle);

  }
  */

}

void __cyg_profile_func_exit(void* func, void* caller) {


  /*
     FuncPtr hello_func = print_fn;
     hello_func(3);
     */

  // print_fn(1);

}
